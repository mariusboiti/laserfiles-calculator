import {
  BadRequestException,
  Body,
  Controller,
  Headers,
  HttpCode,
  HttpStatus,
  Logger,
  Post,
  Req,
} from '@nestjs/common';
import { Request } from 'express';
import { WebhooksService } from './webhooks.service';

type BillingEvent =
  | 'order.completed'
  | 'subscription.renewed'
  | 'subscription.cancelled';

type BillingWebhookDto = {
  eventId: string;
  event: BillingEvent;
  email: string;
  wpUserId: number;
  items: Array<{ productId: number; qty: number }>;
  timestamp: number;
};

@Controller('webhooks/wp')
export class WebhooksController {
  private readonly logger = new Logger(WebhooksController.name);

  constructor(private readonly webhooksService: WebhooksService) {}

  // Final URL: /webhooks/wp/billing (and behind nginx: /api-backend/webhooks/wp/billing)
  @Post('billing')
  @HttpCode(HttpStatus.OK)
  async handleWpBillingWebhook(
    @Req() req: Request & { rawBody?: Buffer },
    @Headers('x-wp-signature') wpSignature?: string,
    @Headers('x-wc-webhook-signature') wcSignature?: string,
    @Body() payload?: BillingWebhookDto,
  ) {
    const signature = wpSignature || wcSignature;

    if (!signature) {
      this.logger.warn('Webhook received without signature/secret header');
      throw new BadRequestException('Missing signature');
    }

    // IMPORTANT:
    // Prefer rawBody for signature checks (Woo sends signature over raw bytes)
    // Fallback to payload if rawBody isn't available.
    const bodyForVerify = (req.rawBody ? req.rawBody.toString('utf8') : JSON.stringify(payload ?? {}));

    // Your service should verify signature and throw if invalid.
    // If your service expects parsed payload instead, adapt it there.
    this.webhooksService.verifyWpSignature(bodyForVerify, signature);

    // Continue with your existing logic (likely in service)
    return this.webhooksService.handleBillingWebhook(payload as any);
  }
}
